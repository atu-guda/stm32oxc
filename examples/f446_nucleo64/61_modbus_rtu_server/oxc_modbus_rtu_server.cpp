#include <cstring>
#include <iterator>
#include <algorithm>

#include <oxc_auto.h>

#include <oxc_modbus_rtu_server.h>


// ================================== common ModbusRtu ========================
// TODO: separate file, may be used with client

uint16_t calcRtuCrc( cbyte_span s )
{
  uint8_t  uh { 0xFF }, ul { 0xFF };

  for( auto c : s ) {
    uint16_t idx = ul ^ c;
    ul = ( uint8_t )( uh ^ ModbusRtu_CRC_hi[idx] );
    uh = ModbusRtu_CRC_lo[idx];
  }
  return ( uint16_t )( uh << 8 | ul );
}

uint16_t calcRtuCrcSub( cbyte_span s )
{
  return calcRtuCrc( s.subspan( 0, s.size()-2 ) );
}

bool checkRtuCrc( cbyte_span s )
{
  if( s.size() < 3 ) {
    return false;
  }
  return ( *std::bit_cast<uint16_t*>( s.data() + ( s.size()-2 ) ) ) == calcRtuCrcSub( s );
}


void embedRtuCrc( byte_span s )
{
  if( s.size() < 3 ) {
    return;
  }
  *std::bit_cast<uint16_t*>( s.data() + ( s.size()-2 ) ) = calcRtuCrcSub( s );
}


const uint8_t ModbusRtu_CRC_hi[256]  {
  // 0     1     2     3      4     5     6     7      8     9     A     B      C     D     E     F
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0x00
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0x10
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0x20
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0x30
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0x40
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0x50
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0x60
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0x70
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0x80
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0x90
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0xA0
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0xB0
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  // 0xC0
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0xD0
  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40,  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  // 0xE0
  0x00, 0xC1, 0x81, 0x40,  0x01, 0xC0, 0x80, 0x41,  0x01, 0xC0, 0x80, 0x41,  0x00, 0xC1, 0x81, 0x40   // 0xF0
};

const uint8_t ModbusRtu_CRC_lo[256]  {
  // 0     1     2     3      4     5     6     7      8     9     A     B      C     D     E     F
  0x00, 0xC0, 0xC1, 0x01,  0xC3, 0x03, 0x02, 0xC2,  0xC6, 0x06, 0x07, 0xC7,  0x05, 0xC5, 0xC4, 0x04,  // 0x00
  0xCC, 0x0C, 0x0D, 0xCD,  0x0F, 0xCF, 0xCE, 0x0E,  0x0A, 0xCA, 0xCB, 0x0B,  0xC9, 0x09, 0x08, 0xC8,  // 0x10
  0xD8, 0x18, 0x19, 0xD9,  0x1B, 0xDB, 0xDA, 0x1A,  0x1E, 0xDE, 0xDF, 0x1F,  0xDD, 0x1D, 0x1C, 0xDC,  // 0x20
  0x14, 0xD4, 0xD5, 0x15,  0xD7, 0x17, 0x16, 0xD6,  0xD2, 0x12, 0x13, 0xD3,  0x11, 0xD1, 0xD0, 0x10,  // 0x30
  0xF0, 0x30, 0x31, 0xF1,  0x33, 0xF3, 0xF2, 0x32,  0x36, 0xF6, 0xF7, 0x37,  0xF5, 0x35, 0x34, 0xF4,  // 0x40
  0x3C, 0xFC, 0xFD, 0x3D,  0xFF, 0x3F, 0x3E, 0xFE,  0xFA, 0x3A, 0x3B, 0xFB,  0x39, 0xF9, 0xF8, 0x38,  // 0x50
  0x28, 0xE8, 0xE9, 0x29,  0xEB, 0x2B, 0x2A, 0xEA,  0xEE, 0x2E, 0x2F, 0xEF,  0x2D, 0xED, 0xEC, 0x2C,  // 0x60
  0xE4, 0x24, 0x25, 0xE5,  0x27, 0xE7, 0xE6, 0x26,  0x22, 0xE2, 0xE3, 0x23,  0xE1, 0x21, 0x20, 0xE0,  // 0x70
  0xA0, 0x60, 0x61, 0xA1,  0x63, 0xA3, 0xA2, 0x62,  0x66, 0xA6, 0xA7, 0x67,  0xA5, 0x65, 0x64, 0xA4,  // 0x80
  0x6C, 0xAC, 0xAD, 0x6D,  0xAF, 0x6F, 0x6E, 0xAE,  0xAA, 0x6A, 0x6B, 0xAB,  0x69, 0xA9, 0xA8, 0x68,  // 0x90
  0x78, 0xB8, 0xB9, 0x79,  0xBB, 0x7B, 0x7A, 0xBA,  0xBE, 0x7E, 0x7F, 0xBF,  0x7D, 0xBD, 0xBC, 0x7C,  // 0xA0
  0xB4, 0x74, 0x75, 0xB5,  0x77, 0xB7, 0xB6, 0x76,  0x72, 0xB2, 0xB3, 0x73,  0xB1, 0x71, 0x70, 0xB0,  // 0xB0
  0x50, 0x90, 0x91, 0x51,  0x93, 0x53, 0x52, 0x92,  0x96, 0x56, 0x57, 0x97,  0x55, 0x95, 0x94, 0x54,  // 0xC0
  0x9C, 0x5C, 0x5D, 0x9D,  0x5F, 0x9F, 0x9E, 0x5E,  0x5A, 0x9A, 0x9B, 0x5B,  0x99, 0x59, 0x58, 0x98,  // 0xD0
  0x88, 0x48, 0x49, 0x89,  0x4B, 0x8B, 0x8A, 0x4A,  0x4E, 0x8E, 0x8F, 0x4F,  0x8D, 0x4D, 0x4C, 0x8C,  // 0xE0
  0x44, 0x84, 0x85, 0x45,  0x87, 0x47, 0x46, 0x86,  0x82, 0x42, 0x43, 0x83,  0x41, 0x81, 0x80, 0x40   // 0xF0
};

// ==================== packet structures =================================================


bool ModbusRtuReadNReq::check( cbyte_span s )
{
  if( s.size() != sizeof(ModbusRtuReadNReq) ) {
    return false;
  }
  if( ! checkRtuCrc( s ) ) {
    return false;
  }

  auto r = std::bit_cast<ModbusRtuReadNReq *>(s.data());
  return r->fun == ModbusFunctionCode::ReadHoldingRegs;
}

bool ModbusRtuReadNReq::make( uint8_t addr, uint16_t start, uint16_t n, byte_span s )
{
  if( s.size() != sizeof(ModbusRtuReadNReq) ) {
    return false;
  }
  auto r = std::bit_cast<ModbusRtuReadNReq *>(s.data());
  r->fill( addr, start, n );
  embedRtuCrc( s );
  return true;
}


bool ModbusRtuWrite1Req::check( cbyte_span s )
{
  if( s.size() != sizeof(ModbusRtuWrite1Req) ) {
    return false;
  }
  if( ! checkRtuCrc( s ) ) {
    return false;
  }

  auto r = std::bit_cast<ModbusRtuWrite1Req *>(s.data());
  return r->fun == ModbusFunctionCode::WriteSingleReg;
}

bool ModbusRtuWrite1Req::make( uint8_t addr, uint16_t reg, uint16_t val, byte_span s )
{
  if( s.size() != sizeof(ModbusRtuWrite1Req) ) {
    return false;
  }
  auto r = std::bit_cast<ModbusRtuWrite1Req*>(s.data());
  r->fill( addr, reg, val );
  embedRtuCrc( s );
  return true;
}


bool ModbusRtuReadNRespHead::check( cbyte_span s )
{
  if( s.size() < sizeof(ModbusRtuReadNRespHead) + sizeof(uint16_t) ) {
    // cout << "Err: size " << s.size() << endl;
    return false;
  }
  if( ! checkRtuCrc( s ) ) {
    // cout << "Err: crc " << s.size() << endl;
    return false;
  }

  auto r = std::bit_cast<ModbusRtuWrite1Req *>(s.data());
  return r->fun == ModbusFunctionCode::ReadHoldingRegs;
}

bool ModbusRtuReadNRespHead::make( uint8_t addr, uint8_t a_n, const uint16_t * /*vals*/, byte_span s )
{
  if( s.size() != sizeof(ModbusRtuReadNRespHead) ) {
    return false;
  }
  auto r = std::bit_cast<ModbusRtuReadNRespHead*>(s.data());
  r->fill( addr, a_n );
  embedRtuCrc( s );
  return true;
}

uint16_t ModbusRtuReadNRespHead::get_v( unsigned i ) const
{
  if( i >= get_n() ) {
    return 0;
  }
  const uint16_t *pd = std::bit_cast<const uint16_t *>( &bytes  + sizeof(uint8_t) );
  return rev16( pd[i] );
}


// ================================================= server ===============================

MODBUS_RTU_server::MODBUS_RTU_server( USART_TypeDef *a_uart )
  : uart( a_uart )
{
  reset();
}

void MODBUS_RTU_server::reset()
{
  // state = ST_IDLE;
  last_uart_status = 0;
  n_readed_regs = 0; start_reg = 0;
  std::ranges::fill( ibuf, '\x00' );
  std::ranges::fill( obuf, '\x00' );
}


bool MODBUS_RTU_server::writeReg( uint8_t addr, uint16_t reg, uint16_t val )
{
  byte_span sp_o { ModbusRtuWrite1Req::make_span( obuf ) };
  auto rc_b = ModbusRtuWrite1Req::make( addr, reg, val, sp_o );
  if( !rc_b ) {
    errno = 5000;
    return rc_b;
  }
  n_readed_regs = 0; start_reg = 0;

  // dump8( obuf, sizeof(ModbusRtuWrite1Req) );

  HAL_UART_Receive( &huart_modbus, (uint8_t*)ibuf, sizeof(ibuf), 0 ); // clear
  auto rc = HAL_UART_Transmit( &huart_modbus, obuf, sizeof(ModbusRtuWrite1Req), tout_write );
  if( rc != HAL_OK ) {
    errno = 5001;
    return false;
  }

  if( addr == 0 ) { // broadcast = no replay
      return true;
  }

  // BUG: need correct read, but this method works for now
  byte_span sp_i { ModbusRtuWrite1Req::make_span( ibuf ) };
  std::ranges::fill( sp_i, '\0' );
  rc = HAL_UART_Receive( &huart_modbus, (uint8_t*)ibuf, sizeof(ModbusRtuWrite1Req), tout_read );

  // dump8( ibuf, sizeof(ModbusRtuWrite1Req) );

  if ( rc != HAL_OK ) {
    errno = 5002;
    return false;
  }
  if( !checkRtuCrc( sp_i ) ) {
    errno = 5003;
    return false;
  }
  if( ibuf[0] != addr ) {
    errno = 5004;
    return false;
  }
  if( ibuf[1] != (uint8_t)ModbusFunctionCode::WriteSingleReg ) {
    errno = 5005;
    return false;
  }
  return true;
}

bool MODBUS_RTU_server::readRegs( uint8_t addr, uint16_t start, uint16_t n )
{
  if( addr < 1 ||  n > 125 || ((unsigned)start+n) > 0xFFFE ) {
    errno = 5010;
    return false;
  }
  n_readed_regs = 0; start_reg = 0;

  byte_span sp_o { ModbusRtuReadNReq::make_span( obuf ) };
  auto rc_b = ModbusRtuReadNReq::make( addr, start, n, sp_o );
  if( !rc_b ) {
    errno = 5000;
    return rc_b;
  }

  dump8( obuf, sizeof(ModbusRtuReadNReq) );

  HAL_UART_Receive( &huart_modbus, (uint8_t*)ibuf, sizeof(ibuf), 0 ); // clear
  auto rc = HAL_UART_Transmit( &huart_modbus, obuf, sizeof(ModbusRtuReadNReq), tout_write );
  if( rc != HAL_OK ) {
    errno = 5001;
    return false;
  }

  // BUG: need correct read, but this method works for now
  byte_span sp_i { ModbusRtuReadNRespHead::make_span( ibuf, n ) };
  std::ranges::fill( sp_i, '\0' );
  rc = HAL_UART_Receive( &huart_modbus, (uint8_t*)ibuf, sp_i.size(), tout_read );

  dump8( ibuf, sp_o.size() );

  if ( rc != HAL_OK ) {
    errno = 5002;
    return false;
  }
  if( !checkRtuCrc( sp_i ) ) {
    errno = 5003;
    return false;
  }
  if( ibuf[0] != addr ) {
    errno = 5004;
    return false;
  }
  if( ibuf[1] != (uint8_t)ModbusFunctionCode::ReadHoldingRegs ) {
    errno = 5005;
    return false;
  }
  n_readed_regs = n; start_reg = start;
  return true;
}

uint16_t MODBUS_RTU_server::getReg( uint16_t i ) const
{
  if( i < start_reg ) {
    return 0;
  }
  i -= start_reg;
  if( i >= n_readed_regs ) {
    return 0;
  }
  auto vs = std::bit_cast<uint16_t *>( ibuf+sizeof(ModbusRtuReadNRespHead) );
  return rev16( vs[i] );
}

